This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
index.css
index.html
package.json
postcss.config.js
src/App.vue
src/components/AppHeader.vue
src/components/CompanyGraph.vue
src/db.js
src/logging.js
src/main.js
tailwind.config.js
vite.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="index.css">
/* frontend/src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
</file>

<file path="index.html">
<!-- frontend/index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Company Visualizer</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "company_visualiser",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "vite",
    "build": "vite build && mv ../static/dist/index.html ../templates/index.html",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "packageManager": "pnpm@10.16.1",
  "dependencies": {
    "@vue-flow/background": "^1.3.2",
    "@vue-flow/controls": "^1.1.3",
    "@vue-flow/core": "^1.46.4",
    "@vue-flow/minimap": "^1.5.4",
    "dexie": "^4.2.0",
    "tailwindcss": "^4.1.13",
    "vue": "^3.5.21",
    "xlsx": "^0.18.5"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4.1.13",
    "@vitejs/plugin-vue": "^6.0.1",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.6",
    "vite": "^7.1.5"
  }
}
</file>

<file path="postcss.config.js">
// frontend/postcss.config.js
export default {
  plugins: {
    // This has been updated to use the new, dedicated package.
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
</file>

<file path="src/App.vue">
<!-- frontend/src/App.vue -->
<template>
  <div class="h-screen w-screen bg-gray-100 flex flex-col">
    <!-- LAYOUT FIX: Added a fixed height to the header (h-16) -->
    <header class="bg-white shadow-md p-4 flex items-center justify-between h-16">
      <h1 class="text-2xl font-bold text-gray-800">Company Structure Visualizer</h1>
      <label class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors duration-300">
        <span>Upload XLSX</span>
        <input type="file" @change="handleFileUpload" class="hidden" accept=".xlsx" />
      </label>
    </header>

    <!-- LAYOUT FIX: Changed from flex-grow to an explicit height calculation.
         This ensures the container has a size before the graph component mounts. -->
    <main class="relative h-[calc(100vh-4rem)]">
      <VueFlow v-model="elements" :fit-view-on-init="true" class="w-full h-full bg-gray-200">
        <Background />
        <MiniMap />
        <Controls />
      </VueFlow>
      <div v-if="isLoading" class="absolute inset-0 bg-gray-500 bg-opacity-50 flex items-center justify-center">
        <p class="text-white text-xl">Processing file...</p>
      </div>
    </main>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { VueFlow } from '@vue-flow/core';
import { Background } from '@vue-flow/background';
import { MiniMap } from '@vue-flow/minimap';
import { Controls } from '@vue-flow/controls';
import { db } from './db';

// Import Vue Flow styles
import '@vue-flow/core/dist/style.css';
import '@vue-flow/core/dist/theme-default.css';
import '@vue-flow/controls/dist/style.css';
import '@vue-flow/minimap/dist/style.css';

const elements = ref([]);
const isLoading = ref(false);

const handleFileUpload = async (event) => {
  const file = event.target.files[0];
  if (!file) return;

  isLoading.value = true;

  try {
    const XLSX = await import('xlsx');
    const reader = new FileReader();

    reader.onload = async (e) => {
      try {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const companiesSheet = workbook.Sheets['Companies'];
        const ownershipSheet = workbook.Sheets['Ownership'];

        if (!companiesSheet || !ownershipSheet) {
          alert('Spreadsheet must contain "Companies" and "Ownership" sheets.');
          return;
        }

        const rawCompanies = XLSX.utils.sheet_to_json(companiesSheet);
        const rawOwnership = XLSX.utils.sheet_to_json(ownershipSheet);

        // --- DATABASE REFACTOR ---
        // Use a Dexie transaction for an all-or-nothing save operation.
        await db.transaction('rw', db.spreadsheets, db.companies, db.ownership, async () => {
          // 1. Create a record for the new spreadsheet upload.
          const spreadsheetId = await db.spreadsheets.add({
            name: file.name,
            lastUpdated: new Date(),
          });
          console.log(`Created new spreadsheet record with ID: ${spreadsheetId}`);

          // 2. Process companies, generating a UUID for each and creating a name-to-UUID map.
          const nameToUuidMap = new Map();
          const companiesToSave = rawCompanies.map(c => {
            const name = c['Company Name'] ? String(c['Company Name']).trim() : null;
            if (!name) return null;
            const uuid = crypto.randomUUID();
            nameToUuidMap.set(name, uuid);
            return {
              spreadsheetId,
              uuid,
              companyName: name,
              companyNumber: c['Company Number'] || null,
            };
          }).filter(Boolean);
          await db.companies.bulkAdd(companiesToSave);
          console.log(`Saved ${companiesToSave.length} companies.`);

          // 3. Process ownership relationships using the UUID map for linking.
          const ownershipToSave = rawOwnership.map(o => {
            const ownerName = o['Owner'] ? String(o['Owner']).trim() : null;
            const ownsName = o['Owns'] ? String(o['Owns']).trim() : null;
            if (!ownerName || !ownsName) return null;

            return {
              spreadsheetId,
              ownerUuid: nameToUuidMap.get(ownerName),
              ownsUuid: nameToUuidMap.get(ownsName),
              percentage: o['Percentage Ownership'] || 0,
            };
          }).filter(o => o && o.ownerUuid && o.ownsUuid); // Ensure relationships are valid
          await db.ownership.bulkAdd(ownershipToSave);
          console.log(`Saved ${ownershipToSave.length} ownership relations.`);

          // 4. Generate the graph with the newly saved, structured data.
          generateGraphData(companiesToSave, ownershipToSave);
        });

      } catch (error) {
        console.error('Error processing file:', error);
        alert('There was an error processing the spreadsheet.');
      } finally {
        isLoading.value = false;
        event.target.value = '';
      }
    };
    reader.readAsArrayBuffer(file);
  } catch (error) {
    console.error('Failed to load xlsx library:', error);
    isLoading.value = false;
  }
};

const generateGraphData = (companies, ownership) => {
  // --- DATABASE REFACTOR ---
  // Now uses UUIDs for IDs, which is much more robust and prevents name clashes.
  const graphNodes = companies.map(company => ({
    id: company.uuid, // Use the unique ID for the node
    label: company.companyName, // Use the name for the display label
    position: { x: Math.random() * 500, y: Math.random() * 500 },
  }));

  const graphEdges = ownership.map(rel => ({
    id: `e-${rel.ownerUuid}-${rel.ownsUuid}`,
    source: rel.ownerUuid, // Link using the source company's UUID
    target: rel.ownsUuid, // Link using the target company's UUID
    label: `${rel.percentage}%`,
    animated: true,
  }));
  
  elements.value = [...graphNodes, ...graphEdges];
  console.log('Graph data successfully generated and rendered from new schema.');
};

onMounted(async () => {
  // --- DATABASE REFACTOR ---
  // Load the most recently uploaded spreadsheet on startup.
  try {
    const latestSpreadsheet = await db.spreadsheets.orderBy('id').last();

    if (latestSpreadsheet) {
      console.log(`Loading data for spreadsheet ID: ${latestSpreadsheet.id}`);
      // Fetch all companies and ownership records for that spreadsheet.
      const companies = await db.companies.where('spreadsheetId').equals(latestSpreadsheet.id).toArray();
      const ownership = await db.ownership.where('spreadsheetId').equals(latestSpreadsheet.id).toArray();
      
      if (companies.length > 0) {
        generateGraphData(companies, ownership);
      }
    } else {
      console.log('No saved spreadsheets found in Dexie.');
    }
  } catch (error) {
    console.error("Failed to load data from Dexie.", error);
  }
});

</script>

<style>
/* These styles ensure the default Vue Flow attribution is visible */
.vue-flow__attribution {
  background: rgba(255, 255, 255, 0.7);
  padding: 2px 4px;
  border-radius: 4px;
}
</style>
</file>

<file path="src/components/AppHeader.vue">
<template>
  <header class="bg-white border-b border-gray-200 p-4 flex items-center justify-between flex-shrink-0">
    <div>
      <h1 class="text-xl font-bold text-gray-900">Company Structure Visualiser</h1>
      <p class="text-sm text-gray-600 h-5">{{ status }}</p>
    </div>
    <div class="flex items-center gap-4">
      <div v-if="loading" class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
      <label class="bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 cursor-pointer transition-colors" :class="{'opacity-50 cursor-not-allowed': loading}">
        <span>Upload XLSX</span>
        <input type="file" @change="$emit('file-select', $event)" accept=".xlsx" class="hidden" :disabled="loading">
      </label>
    </div>
  </header>
</template>

<script setup>
const props = defineProps({
  status: String,
  loading: Boolean,
});

const emit = defineEmits(['file-select']);
</script>
</file>

<file path="src/components/CompanyGraph.vue">
<template>
  <div style="height: 100%">
    <VueFlow v-model="elements">
      <Background />
    </VueFlow>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue';
import { VueFlow, useVueFlow } from '@vue-flow/core';
import { Background } from '@vue-flow/background';

const props = defineProps({
  companies: Array,
  ownership: Array,
});

const { onConnect, addEdges } = useVueFlow();

const elements = ref([]);

watch(() => [props.companies, props.ownership], () => {
  if (!props.companies || !props.ownership) return;

  const nodes = props.companies.map((company, index) => ({
    id: company.name,
    label: company.name,
    position: { x: index * 200, y: 100 },
  }));

  const edges = props.ownership.map(o => ({
    id: `e-${o.owner}-${o.owned}`,
    source: o.owner,
    target: o.owned,
    label: `${o.percentage_ownership}%`,
    animated: true,
  }));

  elements.value = [...nodes, ...edges];
}, { immediate: true, deep: true });

onConnect((params) => addEdges([params]));
</script>
</file>

<file path="src/db.js">
// frontend/src/db.js
import Dexie from 'dexie';

export const db = new Dexie('CompanyVisualizerDB');

// Define a more robust, relational schema based on your feedback.
// We are bumping the version to 2 to signal a schema change.
db.version(2).stores({
  // ++id is an auto-incrementing primary key. This table tracks uploads.
  spreadsheets: '++id, name, lastUpdated',

  // This table stores individual companies, linked to a spreadsheet.
  // We index 'spreadsheetId' to easily query for all companies in a sheet.
  // We index 'uuid' as it will be the unique ID for graph nodes.
  companies: '++id, spreadsheetId, uuid, companyName',

  // This table stores the ownership links, using the company UUIDs.
  ownership: '++id, spreadsheetId, ownerUuid, ownsUuid',
});
</file>

<file path="src/logging.js">
// static/js/logging.js (ESM)
// Lightweight structured logger with context + global error capture.

const LEVELS = { debug: 10, info: 20, warn: 30, error: 40 };
const LEVEL_NAME = Object.fromEntries(Object.entries(LEVELS).map(([k, v]) => [v, k]));

let globalLevel = (typeof localStorage !== 'undefined' && localStorage.getItem('LOG_LEVEL')) || 'info';
if (!LEVELS[globalLevel]) globalLevel = 'info';

const globalContext = {
  app: 'pdf-text-extractor',
  requestId: sessionStorage.getItem('REQUEST_ID') || null,
};

export function setLogLevel(level) {
  if (LEVELS[level]) {
    globalLevel = level;
    try { localStorage.setItem('LOG_LEVEL', level); } catch {}
  }
}

export function setContext(ctx = {}) {
  Object.assign(globalContext, ctx);
  if (ctx.requestId) {
    try { sessionStorage.setItem('REQUEST_ID', ctx.requestId); } catch {}
  }
}

function nowIso() { return new Date().toISOString(); }

function shouldLog(level) { return LEVELS[level] >= LEVELS[globalLevel]; }

function write(level, ns, msg, extra) {
  if (!shouldLog(level)) return;
  const payload = {
    ts: nowIso(),
    level,
    ns,
    msg,
    ...globalContext,
    ...extra,
  };
  // Console output
  const line = `[${payload.ts}] ${level.toUpperCase()} ${ns}: ${msg}`;
  if (level === 'error') console.error(line, extra || {});
  else if (level === 'warn') console.warn(line, extra || {});
  else if (level === 'info') console.info(line, extra || {});
  else console.debug(line, extra || {});
  // Hook: forward to backend later if desired
}

export function createLogger(namespace) {
  return {
    debug: (msg, extra) => write('debug', namespace, msg, extra),
    info:  (msg, extra) => write('info',  namespace, msg, extra),
    warn:  (msg, extra) => write('warn',  namespace, msg, extra),
    error: (msg, extra) => write('error', namespace, msg, extra),
  };
}

// Global error capture
window.addEventListener('error', (e) => {
  write('error', 'global', e.message || 'uncaught error', { file: e.filename, line: e.lineno, col: e.colno });
});

window.addEventListener('unhandledrejection', (e) => {
  write('error', 'global', 'unhandled rejection', { reason: (e.reason && (e.reason.message || e.reason)) || null });
});

// Helper to extract request-id from responses and set context
export async function logFetch(input, init) {
  const start = performance.now();
  const res = await fetch(input, init);
  const rid = res.headers.get('x-request-id');
  if (rid) setContext({ requestId: rid });
  const ms = Math.round(performance.now() - start);
  write('info', 'fetch', 'http', { url: (typeof input === 'string' ? input : input.url), status: res.status, ms });
  return res;
}
</file>

<file path="src/main.js">
// frontend/src/main.js
import { createApp } from 'vue';
import { createLogger, setContext } from './logging.js';
import App from './App.vue';

// This is the crucial line. It imports your stylesheet, which
// loads Tailwind and allows the application layout to work correctly.
import './index.css';

const log = createLogger('app');
window.LOG = log; // optional global for quick diagnostics

setContext({ env: 'browser', root: window.ROOT_PATH || '' });

const app = createApp(App);
app.mount('#app');

log.info('app.mounted');
</file>

<file path="tailwind.config.js">
// frontend/tailwind.config.js

/** @type {import('tailwindcss').Config} */
export default {
  // This `content` array is the crucial part. It tells Tailwind to scan
  // your HTML file and all of your Vue and JavaScript files inside the `src`
  // directory for any utility classes you've used.
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="vite.config.js">
// frontend/vite.config.js
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';

// https://vitejs.dev/config/
export default defineConfig(({ command }) => {
  // This function allows us to have different configs for 'serve' and 'build'.
  const isProduction = command === 'build';

  return {
    // --- PATH FIX ---
    // Conditionally set the base path.
    // For the production build, we need the full path for FastAPI.
    // For the development server, we use the root path '/' so it works correctly.
    base: isProduction ? '/static/dist/' : '/',
    // --- End of FIX ---

    plugins: [vue()],
    root: '.',
    build: {
      outDir: '../static/dist',
      assetsDir: 'assets',
      manifest: true,
      emptyOutDir: true,
      rollupOptions: {
        input: 'index.html',
      },
    },
    server: {
      // The port was missing, which might cause issues. Let's define it.
      port: 5174,
      proxy: {
        '/api': {
          target: 'http://127.0.0.1:8000',
          changeOrigin: true,
        },
      },
    },
  };
});
</file>

</files>
